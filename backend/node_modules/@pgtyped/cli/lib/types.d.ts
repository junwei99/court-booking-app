import { MappableType, Type } from '@pgtyped/query';
export declare const DefaultTypeMapping: Readonly<{
    int2: import("@pgtyped/query/lib/type").NamedType;
    int4: import("@pgtyped/query/lib/type").NamedType;
    int8: import("@pgtyped/query/lib/type").NamedType;
    smallint: import("@pgtyped/query/lib/type").NamedType;
    int: import("@pgtyped/query/lib/type").NamedType;
    bigint: import("@pgtyped/query/lib/type").NamedType;
    real: import("@pgtyped/query/lib/type").NamedType;
    float4: import("@pgtyped/query/lib/type").NamedType;
    float: import("@pgtyped/query/lib/type").NamedType;
    float8: import("@pgtyped/query/lib/type").NamedType;
    numeric: import("@pgtyped/query/lib/type").NamedType;
    decimal: import("@pgtyped/query/lib/type").NamedType;
    smallserial: import("@pgtyped/query/lib/type").NamedType;
    serial: import("@pgtyped/query/lib/type").NamedType;
    bigserial: import("@pgtyped/query/lib/type").NamedType;
    uuid: import("@pgtyped/query/lib/type").NamedType;
    text: import("@pgtyped/query/lib/type").NamedType;
    varchar: import("@pgtyped/query/lib/type").NamedType;
    char: import("@pgtyped/query/lib/type").NamedType;
    bpchar: import("@pgtyped/query/lib/type").NamedType;
    citext: import("@pgtyped/query/lib/type").NamedType;
    name: import("@pgtyped/query/lib/type").NamedType;
    bit: import("@pgtyped/query/lib/type").NamedType;
    bool: import("@pgtyped/query/lib/type").NamedType;
    boolean: import("@pgtyped/query/lib/type").NamedType;
    date: import("@pgtyped/query/lib/type").NamedType;
    timestamp: import("@pgtyped/query/lib/type").NamedType;
    timestamptz: import("@pgtyped/query/lib/type").NamedType;
    time: import("@pgtyped/query/lib/type").NamedType;
    timetz: import("@pgtyped/query/lib/type").NamedType;
    interval: import("@pgtyped/query/lib/type").NamedType;
    inet: import("@pgtyped/query/lib/type").NamedType;
    cidr: import("@pgtyped/query/lib/type").NamedType;
    macaddr: import("@pgtyped/query/lib/type").NamedType;
    macaddr8: import("@pgtyped/query/lib/type").NamedType;
    money: import("@pgtyped/query/lib/type").NamedType;
    tsvector: import("@pgtyped/query/lib/type").NamedType;
    void: import("@pgtyped/query/lib/type").NamedType;
    json: import("@pgtyped/query/lib/type").NamedType | import("@pgtyped/query/lib/type").AliasedType;
    jsonb: import("@pgtyped/query/lib/type").NamedType | import("@pgtyped/query/lib/type").AliasedType;
    bytea: import("@pgtyped/query/lib/type").NamedType;
    point: Type;
}>;
export type BuiltinTypes = keyof typeof DefaultTypeMapping;
export type TypeMapping = Record<BuiltinTypes, Type> & Record<string, Type>;
export declare function TypeMapping(overrides?: Partial<TypeMapping>): TypeMapping;
/** Wraps a TypeMapping to track which types have been used, to accumulate errors,
 * and emit necessary type definitions. */
export declare class TypeAllocator {
    private mapping;
    private allowUnmappedTypes?;
    errors: Error[];
    imports: {
        [k: string]: Set<string>;
    };
    types: {
        [k: string]: Type;
    };
    constructor(mapping: TypeMapping, allowUnmappedTypes?: boolean | undefined);
    isMappedType(name: string): name is keyof TypeMapping;
    /** Lookup a database-provided type name in the allocator's map */
    use(typeNameOrType: MappableType): string;
    /** Emit a typescript definition for all types that have been used */
    declaration(): string;
}
